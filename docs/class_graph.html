<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Algorithm Prima: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="favicon (1).ico"/></td>
  <td id="projectalign">
   <div id="projectname">Algorithm Prima
   </div>
   <div id="projectbrief">Algorithm Prima &amp; connection components</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> represented as adjacency matrix.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Graph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_graph.png" usemap="#Graph_map" alt=""/>
  <map id="Graph_map" name="Graph_map">
<area href="class_graph_interface.html" title="Graph interface." alt="GraphInterface" shape="rect" coords="0,0,97,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afddb781afb54d18d22732b7bf03763d1" id="r_afddb781afb54d18d22732b7bf03763d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afddb781afb54d18d22732b7bf03763d1">getHomomorphism</a> () const</td></tr>
<tr class="memdesc:afddb781afb54d18d22732b7bf03763d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get graphs homomorphism.  <br /></td></tr>
<tr class="separator:afddb781afb54d18d22732b7bf03763d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b292f42a344c4330ada12a2e73346f" id="r_a48b292f42a344c4330ada12a2e73346f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48b292f42a344c4330ada12a2e73346f">getAdjacencyMatrix</a> () const</td></tr>
<tr class="separator:a48b292f42a344c4330ada12a2e73346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b4d5e9c402b6627751971546c847ab" id="r_a44b4d5e9c402b6627751971546c847ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44b4d5e9c402b6627751971546c847ab">operator==</a> (const <a class="el" href="class_graph.html">Graph</a> &amp;another) const</td></tr>
<tr class="separator:a44b4d5e9c402b6627751971546c847ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c72b8ac4d693c49800a4c7e273654f" id="r_ae4c72b8ac4d693c49800a4c7e273654f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4c72b8ac4d693c49800a4c7e273654f">Graph</a> ()</td></tr>
<tr class="separator:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413d6e1130f8372b0187f9089a0acd30" id="r_a413d6e1130f8372b0187f9089a0acd30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a413d6e1130f8372b0187f9089a0acd30">Graph</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a413d6e1130f8372b0187f9089a0acd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from matrix.  <br /></td></tr>
<tr class="separator:a413d6e1130f8372b0187f9089a0acd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87195bad827d55f9fc186a6935a18cb" id="r_ad87195bad827d55f9fc186a6935a18cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad87195bad827d55f9fc186a6935a18cb">Graph</a> (const <a class="el" href="class_graph.html">Graph</a> &amp;another)</td></tr>
<tr class="memdesc:ad87195bad827d55f9fc186a6935a18cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:ad87195bad827d55f9fc186a6935a18cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6611a0563fef797fc7d0ec65dcf569" id="r_acf6611a0563fef797fc7d0ec65dcf569"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf6611a0563fef797fc7d0ec65dcf569">Graph</a> (int n, double minWeight, double maxWeight, double edgesPercent=100)</td></tr>
<tr class="memdesc:acf6611a0563fef797fc7d0ec65dcf569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:acf6611a0563fef797fc7d0ec65dcf569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ee33783a9de22c037a1a28bc170c58" id="r_a63ee33783a9de22c037a1a28bc170c58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63ee33783a9de22c037a1a28bc170c58">Graph</a> (const std::vector&lt; <a class="el" href="class_graph.html">Graph</a> &gt; &amp;componentsList)</td></tr>
<tr class="memdesc:a63ee33783a9de22c037a1a28bc170c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a63ee33783a9de22c037a1a28bc170c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bdf9a9e37d614b07423d872f44dde8" id="r_ab0bdf9a9e37d614b07423d872f44dde8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0bdf9a9e37d614b07423d872f44dde8">operator=</a> (const <a class="el" href="class_graph.html">Graph</a> &amp;another)</td></tr>
<tr class="separator:ab0bdf9a9e37d614b07423d872f44dde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00396d47291e9acf6efa58c341b46b44" id="r_a00396d47291e9acf6efa58c341b46b44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00396d47291e9acf6efa58c341b46b44">printMatrix</a> () const</td></tr>
<tr class="memdesc:a00396d47291e9acf6efa58c341b46b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print adjacency matrix.  <br /></td></tr>
<tr class="separator:a00396d47291e9acf6efa58c341b46b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cf3ef7595061438dde1a1f5c2e3340" id="r_a08cf3ef7595061438dde1a1f5c2e3340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08cf3ef7595061438dde1a1f5c2e3340">printEdges</a> () const</td></tr>
<tr class="memdesc:a08cf3ef7595061438dde1a1f5c2e3340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print all graph edges.  <br /></td></tr>
<tr class="separator:a08cf3ef7595061438dde1a1f5c2e3340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efe4d805b9f558ceae62f9e4f43c992" id="r_a1efe4d805b9f558ceae62f9e4f43c992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1efe4d805b9f558ceae62f9e4f43c992">addEdge</a> (int vertex1, int vertex2, double weight)</td></tr>
<tr class="memdesc:a1efe4d805b9f558ceae62f9e4f43c992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edge to graph.  <br /></td></tr>
<tr class="separator:a1efe4d805b9f558ceae62f9e4f43c992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab960e31c04f0f1f2cc361f23fc69fda2" id="r_ab960e31c04f0f1f2cc361f23fc69fda2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab960e31c04f0f1f2cc361f23fc69fda2">removeEdge</a> (int vertex1, int vertex2)</td></tr>
<tr class="memdesc:ab960e31c04f0f1f2cc361f23fc69fda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edge from graph.  <br /></td></tr>
<tr class="separator:ab960e31c04f0f1f2cc361f23fc69fda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7fed9be39c325a22880baea25aeb9c" id="r_a7d7fed9be39c325a22880baea25aeb9c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d7fed9be39c325a22880baea25aeb9c">findConnectComponents</a> () const</td></tr>
<tr class="memdesc:a7d7fed9be39c325a22880baea25aeb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds all the connected components of a graph. Works with O(n^2)  <br /></td></tr>
<tr class="separator:a7d7fed9be39c325a22880baea25aeb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e42fdd97c80bd78efaf575f55661770" id="r_a1e42fdd97c80bd78efaf575f55661770"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e42fdd97c80bd78efaf575f55661770">findMinSpanningForest</a> () const</td></tr>
<tr class="memdesc:a1e42fdd97c80bd78efaf575f55661770"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the minimum spanning forest of a graph.  <br /></td></tr>
<tr class="separator:a1e42fdd97c80bd78efaf575f55661770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27481cac3cb5e221fc18d4735e84a018" id="r_a27481cac3cb5e221fc18d4735e84a018"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_graph.html">Graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27481cac3cb5e221fc18d4735e84a018">parallel_findMinSpanningForest</a> ()</td></tr>
<tr class="memdesc:a27481cac3cb5e221fc18d4735e84a018"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the minimum spanning forest of a graph using multiple threads.  <br /></td></tr>
<tr class="separator:a27481cac3cb5e221fc18d4735e84a018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6539d03f6d3f42042196f0f79455bdd8" id="r_a6539d03f6d3f42042196f0f79455bdd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6539d03f6d3f42042196f0f79455bdd8">size</a> () const</td></tr>
<tr class="memdesc:a6539d03f6d3f42042196f0f79455bdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return amount of graph`s vertexes.  <br /></td></tr>
<tr class="separator:a6539d03f6d3f42042196f0f79455bdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548a36226720cfe5158cfd3f22cc839" id="r_a1548a36226720cfe5158cfd3f22cc839"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1548a36226720cfe5158cfd3f22cc839">findGraphWeight</a> () const</td></tr>
<tr class="memdesc:a1548a36226720cfe5158cfd3f22cc839"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the total weight of a graph.  <br /></td></tr>
<tr class="separator:a1548a36226720cfe5158cfd3f22cc839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5925b85235566b19a4c7039586e85eaa" id="r_a5925b85235566b19a4c7039586e85eaa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5925b85235566b19a4c7039586e85eaa">createRandomGraph</a> (int n, double minWeight, double maxWeight, double edgesPercent)</td></tr>
<tr class="memdesc:a5925b85235566b19a4c7039586e85eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create random graph with random generation seed.  <br /></td></tr>
<tr class="separator:a5925b85235566b19a4c7039586e85eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a85d9d514397deaa87dfb8fb6b99bf3" id="r_a5a85d9d514397deaa87dfb8fb6b99bf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a85d9d514397deaa87dfb8fb6b99bf3">createRandomGraph</a> (int n, double minWeight, double maxWeight, unsigned seed, double edgesPercent)</td></tr>
<tr class="memdesc:a5a85d9d514397deaa87dfb8fb6b99bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create graph whith generation seed.  <br /></td></tr>
<tr class="separator:a5a85d9d514397deaa87dfb8fb6b99bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa122d23e6ac32f36a8a3fe3643111b" id="r_aafa122d23e6ac32f36a8a3fe3643111b"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::chrono::duration&lt; double &gt;, std::chrono::duration&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafa122d23e6ac32f36a8a3fe3643111b">sameGraphBenchMark</a> (int n, double edgesPercent, unsigned amountOfMeasurements)</td></tr>
<tr class="memdesc:aafa122d23e6ac32f36a8a3fe3643111b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function benchmarks the performance of the default and parallel implementations of the minimum spanning forest algorithm on the same graph.  <br /></td></tr>
<tr class="separator:aafa122d23e6ac32f36a8a3fe3643111b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d6a23a7a4ee4a3530d119154b6ead6" id="r_a70d6a23a7a4ee4a3530d119154b6ead6"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::chrono::duration&lt; double &gt;, std::chrono::duration&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70d6a23a7a4ee4a3530d119154b6ead6">sameGraphBenchMark</a> (int n, double edgesPercent, unsigned amountOfMeasurements, unsigned seed)</td></tr>
<tr class="memdesc:a70d6a23a7a4ee4a3530d119154b6ead6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function benchmarks the performance of the default and parallel implementations of the minimum spanning forest algorithm on the same graph with a specified seed for the random number generator.  <br /></td></tr>
<tr class="separator:a70d6a23a7a4ee4a3530d119154b6ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa436cfdc26c5d629b9044ac990f328e3" id="r_aa436cfdc26c5d629b9044ac990f328e3"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::chrono::duration&lt; double &gt;, std::chrono::duration&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa436cfdc26c5d629b9044ac990f328e3">differentGraphsBenchMark</a> (int n, double edgesPercent, unsigned amountOfMeasurements)</td></tr>
<tr class="memdesc:aa436cfdc26c5d629b9044ac990f328e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function benchmarks the performance of the default and parallel implementations of the minimum spanning forest algorithm on different graphs.  <br /></td></tr>
<tr class="separator:aa436cfdc26c5d629b9044ac990f328e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64516282c804cd4b2029f8a8c6c2d968" id="r_a64516282c804cd4b2029f8a8c6c2d968"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64516282c804cd4b2029f8a8c6c2d968">test</a> ()</td></tr>
<tr class="memdesc:a64516282c804cd4b2029f8a8c6c2d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method to testing all graph methods.  <br /></td></tr>
<tr class="separator:a64516282c804cd4b2029f8a8c6c2d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> represented as adjacency matrix. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c72b8ac4d693c49800a4c7e273654f" name="ae4c72b8ac4d693c49800a4c7e273654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c72b8ac4d693c49800a4c7e273654f">&#9670;&#160;</a></span>Graph() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a413d6e1130f8372b0187f9089a0acd30" name="a413d6e1130f8372b0187f9089a0acd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413d6e1130f8372b0187f9089a0acd30">&#9670;&#160;</a></span>Graph() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor from matrix. </p>

</div>
</div>
<a id="ad87195bad827d55f9fc186a6935a18cb" name="ad87195bad827d55f9fc186a6935a18cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87195bad827d55f9fc186a6935a18cb">&#9670;&#160;</a></span>Graph() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>another</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="acf6611a0563fef797fc7d0ec65dcf569" name="acf6611a0563fef797fc7d0ec65dcf569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6611a0563fef797fc7d0ec65dcf569">&#9670;&#160;</a></span>Graph() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minWeight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>maxWeight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>edgesPercent</em><span class="paramdefsep"> = </span><span class="paramdefval">100</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of vertexes in the graph </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minWeight</td><td>minimum possible edge weight. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxWeight</td><td>maximum possible edge weight. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgesPercent</td><td>percent of all edges that will be created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63ee33783a9de22c037a1a28bc170c58" name="a63ee33783a9de22c037a1a28bc170c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ee33783a9de22c037a1a28bc170c58">&#9670;&#160;</a></span>Graph() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_graph.html">Graph</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>componentsList</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">componentsList</td><td>list of components, that will merge into one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1efe4d805b9f558ceae62f9e4f43c992" name="a1efe4d805b9f558ceae62f9e4f43c992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efe4d805b9f558ceae62f9e4f43c992">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add edge to graph. </p>
<p>if vertexes nomers out of range, method do not add edge. if vertex1 == vertex2 -&gt; weight = 0. Also add edge for v2 -&gt; v1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex1</td><td>nomer of first vertex in edge </td></tr>
    <tr><td class="paramname">vertex2</td><td>nomer of second vertex in edge </td></tr>
    <tr><td class="paramname">weight</td><td>weight of edge </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_graph_interface.html#aa87bdb8edfc0629346f6dd9c2407ce45">GraphInterface</a>.</p>

</div>
</div>
<a id="a5925b85235566b19a4c7039586e85eaa" name="a5925b85235566b19a4c7039586e85eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5925b85235566b19a4c7039586e85eaa">&#9670;&#160;</a></span>createRandomGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::createRandomGraph </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minWeight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>maxWeight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>edgesPercent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create random graph with random generation seed. </p>

</div>
</div>
<a id="a5a85d9d514397deaa87dfb8fb6b99bf3" name="a5a85d9d514397deaa87dfb8fb6b99bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a85d9d514397deaa87dfb8fb6b99bf3">&#9670;&#160;</a></span>createRandomGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::createRandomGraph </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minWeight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>maxWeight</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>seed</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>edgesPercent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create graph whith generation seed. </p>

</div>
</div>
<a id="aa436cfdc26c5d629b9044ac990f328e3" name="aa436cfdc26c5d629b9044ac990f328e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa436cfdc26c5d629b9044ac990f328e3">&#9670;&#160;</a></span>differentGraphsBenchMark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::chrono::duration&lt; double &gt;, std::chrono::duration&lt; double &gt; &gt; Graph::differentGraphsBenchMark </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>edgesPercent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>amountOfMeasurements</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function benchmarks the performance of the default and parallel implementations of the minimum spanning forest algorithm on different graphs. </p>
<p>The function creates a random graph and measures the time taken by the default and parallel implementations of the minimum spanning forest algorithm to process the graph. The function repeats this process with a new random graph a specified number of times and returns the total time taken by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of vertices in the graph. </td></tr>
    <tr><td class="paramname">edgesPercent</td><td>The percentage of edges in the graph. </td></tr>
    <tr><td class="paramname">amountOfMeasurements</td><td>The number of times the benchmarking process is repeated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::chrono::duration&lt;double&gt;, std::chrono::duration&lt;double&gt;&gt; - A pair of durations, where the first duration is the total time taken by the default implementation and the second duration is the total time taken by the parallel implementation. </dd></dl>

</div>
</div>
<a id="a7d7fed9be39c325a22880baea25aeb9c" name="a7d7fed9be39c325a22880baea25aeb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7fed9be39c325a22880baea25aeb9c">&#9670;&#160;</a></span>findConnectComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_graph.html">Graph</a> &gt; Graph::findConnectComponents </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function finds all the connected components of a graph. Works with O(n^2) </p>
<p>The function iterates over all the vertices of the graph. For each vertex, if it has not been checked (i.e., it is not part of a previously found connected component), the function finds the connected component for that vertex and adds it to the list of connected components.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Graph&gt; - A vector of <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> objects, where each <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> object represents a connected component of the graph. </dd></dl>
<p>&lt; A vector of <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> objects to store the connected components of the graph.</p>
<p>&lt; A vector of booleans to keep track of which vertices have been checked.</p>
<p>&lt; Initialize all vertices as unchecked.</p>
<p>&lt; if the vertex has not been checked</p>
<p>&lt; ...find the connected component for that vertex and add it to the list of connected components.</p>
<p>&lt; Return the list of connected components.</p>

<p>Implements <a class="el" href="class_graph_interface.html#a93497ff24c31a4a0e0426a1099845369">GraphInterface</a>.</p>

</div>
</div>
<a id="a1548a36226720cfe5158cfd3f22cc839" name="a1548a36226720cfe5158cfd3f22cc839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1548a36226720cfe5158cfd3f22cc839">&#9670;&#160;</a></span>findGraphWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::findGraphWeight </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the total weight of a graph. </p>
<p>The function iterates over all the edges in the adjacency matrix of the graph. If the weight of an edge is not infinity (i.e., the edge exists), it adds the weight of the edge to the total weight of the graph. The function returns the total weight of the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>double - The total weight of the graph. </dd></dl>
<p>&lt; The total weight of the graph.</p>
<p>&lt; For each vertex in the graph...</p>
<p>&lt; if the edge exists</p>
<p>&lt; åadd the weight of the edge to the total weight of the graph.</p>

<p>Implements <a class="el" href="class_graph_interface.html#a6b4774fd2dbdf53c503dbe33cd61cb0d">GraphInterface</a>.</p>

</div>
</div>
<a id="a1e42fdd97c80bd78efaf575f55661770" name="a1e42fdd97c80bd78efaf575f55661770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e42fdd97c80bd78efaf575f55661770">&#9670;&#160;</a></span>findMinSpanningForest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_graph.html">Graph</a> &gt; Graph::findMinSpanningForest </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function finds the minimum spanning forest of a graph. </p>
<p>The function first finds the connected components of the graph. For each connected component, it finds the minimum spanning tree. All these minimum spanning trees together form the minimum spanning forest of the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Graph&gt; - A vector of <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> objects, where each <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> object represents a minimum spanning tree of a connected component of the graph. </dd></dl>
<p>&lt; A vector of <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> objects, where each <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> object represents a connected component of the graph.</p>
<p>&lt; A vector of <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> objects to store the minimum spanning trees of the connected components.</p>
<p>&lt; For each connected component...</p>
<p>&lt; ...find its minimum spanning tree and add it to the minimum spanning forest.</p>
<p>&lt; Return the minimum spanning forest.</p>

<p>Implements <a class="el" href="class_graph_interface.html#af2fcf1dfb718464ae472175aeb3afbf3">GraphInterface</a>.</p>

</div>
</div>
<a id="a48b292f42a344c4330ada12a2e73346f" name="a48b292f42a344c4330ada12a2e73346f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b292f42a344c4330ada12a2e73346f">&#9670;&#160;</a></span>getAdjacencyMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; double &gt; &gt; Graph::getAdjacencyMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_graph_interface.html#a0e4f69c4484e9a239a9b4ca0e4149a6a">GraphInterface</a>.</p>

</div>
</div>
<a id="afddb781afb54d18d22732b7bf03763d1" name="afddb781afb54d18d22732b7bf03763d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddb781afb54d18d22732b7bf03763d1">&#9670;&#160;</a></span>getHomomorphism()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Graph::getHomomorphism </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get graphs homomorphism. </p>

<p>Implements <a class="el" href="class_graph_interface.html#ae550ba320ab69787bf472039a70ecefb">GraphInterface</a>.</p>

</div>
</div>
<a id="ab0bdf9a9e37d614b07423d872f44dde8" name="ab0bdf9a9e37d614b07423d872f44dde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bdf9a9e37d614b07423d872f44dde8">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> &amp; Graph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>another</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44b4d5e9c402b6627751971546c847ab" name="a44b4d5e9c402b6627751971546c847ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b4d5e9c402b6627751971546c847ab">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_graph.html">Graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>another</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27481cac3cb5e221fc18d4735e84a018" name="a27481cac3cb5e221fc18d4735e84a018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27481cac3cb5e221fc18d4735e84a018">&#9670;&#160;</a></span>parallel_findMinSpanningForest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_graph.html">Graph</a> &gt; Graph::parallel_findMinSpanningForest </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function finds the minimum spanning forest of a graph using multiple threads. </p>
<p>The function creates a task group and runs two tasks in parallel: one to find all the connected components of the graph, and the other to find the minimum spanning tree of each connected component. Once all tasks have completed, the function returns the minimum spanning forest.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Graph&gt; - A vector of <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> objects, where each <a class="el" href="class_graph.html" title="Graph represented as adjacency matrix.">Graph</a> object represents a minimum spanning tree of a connected component of the graph. </dd></dl>

<p>Implements <a class="el" href="class_graph_interface.html#ae6782ef9316dea007f14f480fa1e327f">GraphInterface</a>.</p>

</div>
</div>
<a id="a08cf3ef7595061438dde1a1f5c2e3340" name="a08cf3ef7595061438dde1a1f5c2e3340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cf3ef7595061438dde1a1f5c2e3340">&#9670;&#160;</a></span>printEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::printEdges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print all graph edges. </p>

<p>Implements <a class="el" href="class_graph_interface.html#a19c227fb7020daea62a298f8e52b253d">GraphInterface</a>.</p>

</div>
</div>
<a id="a00396d47291e9acf6efa58c341b46b44" name="a00396d47291e9acf6efa58c341b46b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00396d47291e9acf6efa58c341b46b44">&#9670;&#160;</a></span>printMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::printMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print adjacency matrix. </p>

<p>Implements <a class="el" href="class_graph_interface.html#a018c4fec389b889a0d96d1e8fdb35c4c">GraphInterface</a>.</p>

</div>
</div>
<a id="ab960e31c04f0f1f2cc361f23fc69fda2" name="ab960e31c04f0f1f2cc361f23fc69fda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab960e31c04f0f1f2cc361f23fc69fda2">&#9670;&#160;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::removeEdge </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove edge from graph. </p>
<p>if vertexes nomers out of range, method do not remove edge. if vertex1 == vertex2 -&gt; weight = 0. Also add edge for v2 -&gt; v1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex1</td><td>nomer of first vertex in edge </td></tr>
    <tr><td class="paramname">vertex2</td><td>nomer of second vertex in edge </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_graph_interface.html#a1e86b8e24da3bbdd8a37223a993f7e6e">GraphInterface</a>.</p>

</div>
</div>
<a id="aafa122d23e6ac32f36a8a3fe3643111b" name="aafa122d23e6ac32f36a8a3fe3643111b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa122d23e6ac32f36a8a3fe3643111b">&#9670;&#160;</a></span>sameGraphBenchMark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::chrono::duration&lt; double &gt;, std::chrono::duration&lt; double &gt; &gt; Graph::sameGraphBenchMark </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>edgesPercent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>amountOfMeasurements</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function benchmarks the performance of the default and parallel implementations of the minimum spanning forest algorithm on the same graph. </p>
<p>The function creates a random graph and measures the time taken by the default and parallel implementations of the minimum spanning forest algorithm to process the graph. The function repeats this process a specified number of times and returns the total time taken by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of vertices in the graph. </td></tr>
    <tr><td class="paramname">edgesPercent</td><td>The percentage of edges in the graph. </td></tr>
    <tr><td class="paramname">amountOfMeasurements</td><td>The number of times the benchmarking process is repeated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::chrono::duration&lt;double&gt;, std::chrono::duration&lt;double&gt;&gt; - A pair of durations, where the first duration is the total time taken by the default implementation and the second duration is the total time taken by the parallel implementation. </dd></dl>

</div>
</div>
<a id="a70d6a23a7a4ee4a3530d119154b6ead6" name="a70d6a23a7a4ee4a3530d119154b6ead6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d6a23a7a4ee4a3530d119154b6ead6">&#9670;&#160;</a></span>sameGraphBenchMark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::chrono::duration&lt; double &gt;, std::chrono::duration&lt; double &gt; &gt; Graph::sameGraphBenchMark </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>edgesPercent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>amountOfMeasurements</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function benchmarks the performance of the default and parallel implementations of the minimum spanning forest algorithm on the same graph with a specified seed for the random number generator. </p>
<p>The function creates a random graph with a specified seed for the random number generator and measures the time taken by the default and parallel implementations of the minimum spanning forest algorithm to process the graph. The function repeats this process a specified number of times and returns the total time taken by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of vertices in the graph. </td></tr>
    <tr><td class="paramname">edgesPercent</td><td>The percentage of edges in the graph. </td></tr>
    <tr><td class="paramname">amountOfMeasurements</td><td>The number of times the benchmarking process is repeated. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed for the random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;std::chrono::duration&lt;double&gt;, std::chrono::duration&lt;double&gt;&gt; - A pair of durations, where the first duration is the total time taken by the default implementation and the second duration is the total time taken by the parallel implementation. </dd></dl>

</div>
</div>
<a id="a6539d03f6d3f42042196f0f79455bdd8" name="a6539d03f6d3f42042196f0f79455bdd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6539d03f6d3f42042196f0f79455bdd8">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return amount of graph`s vertexes. </p>

<p>Implements <a class="el" href="class_graph_interface.html#aa5395f34f7dc197c6d01c1eb7d61fa60">GraphInterface</a>.</p>

</div>
</div>
<a id="a64516282c804cd4b2029f8a8c6c2d968" name="a64516282c804cd4b2029f8a8c6c2d968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64516282c804cd4b2029f8a8c6c2d968">&#9670;&#160;</a></span>test()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::test </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method to testing all graph methods. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li><a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
